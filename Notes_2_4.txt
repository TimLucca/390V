Repitition via Recursion
 
 > (define length
    (lambda (lst)
        (if (null? lst)
            0
            (+ 1 (length (cdr lst))))))

> (trace length)
(length)

> (length '(1 2 3 4))
|(length-of-list (1 2 3 4))
| (length-of-list (2 3 4))
| |(length-of-list (3 4))
| | (length-of-list (4))
| | |(length-of-list ())
| | |0
| | 1
| |2
| 3
|4
4

Trees

> (define tree-copy
    (lambda (tr)
        (if (not (pair? tr))
            tr
            (cons (tree-copy (car tr))
                (tree-copy (cdr tr))))))

> (tree-copy '((a . b) . c))
((a . b) . c)


set! (set-bang)
- used only when state needed between calls
- generally state will be avoided, due to desire for immutability. sometimes needed
- let-bind 

> (define make-counter
    (lambda ()
        (let ([next 0])
            (lambda ()
                (let ([v next])
                    (set! next (+ next 1))
                    v)))))

                    