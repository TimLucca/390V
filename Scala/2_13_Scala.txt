Tail Recursion
- not mutually-recursive methods (optimization only works for functions that recurse on themselves)
- use @tailrec annotation to make sure

Pattern Matching
- similar to switch statement

- '::' is the list seperator
    -so 'case pivot :: tail' pivot becomes the 'car' and tail become the 'cdr'
    - tail.partition(_ < pivot) takes in a function
        - '_' in this case works as an anonymous variable (is like a lambda with a single parameter)
        - partition repeatedly calls the line below it
            - if true is returns the values go before the pivot
            - else the values go after the pivot

    object Quick {
        def qsort(list: List[Int]): List[Int] = list match {
            case Nil => Nil
            case pivot :: tail =>
                val (smaller, larger) = tail.partition(_ < pivot)
                    qsort(smaller) ::: pivot :: qsort(larger)
        }

        def main(args: Array[String]){
            println(qsort(List(4,6,2,8,9,12,5,42)))
        }
    }


Colons

> List(1, 2, 3) :: List(4, 5, 6) // cons
List[Any] = List(List(1, 2, 3), 4, 5, 6)

> List(1, 2, 3) ::: List(4, 5, 6) // append
List[Int] = List(1, 2, 3, 4, 5, 6)


